[SETTINGS]
- NAMESPACE: jumptable_arm
- OPCODE_FORMAT: IIIIIIIIIIII------------DDDD----
- INCLUDES: util cpu
- ARGUMENTS: ARM7TDMI cpu
[/SETTINGS]

[DEFAULT]
{
    error(format("No implementation for opcode 0x" ~ to_hex_string(opcode)));
}
[/DEFAULT]

[RULE ADD_ADC]
- INCLUDE: ----00-010----------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: ADD_ADC
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE AND]
- INCLUDE: ----00-0000---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: AND
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE BIC]
- INCLUDE: ----00-1110---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: BIC
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE B_BL]
- INCLUDE: ----101-------------------------
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: B_BL
[/RULE]

[RULE BX]
- INCLUDE: ----00010010------------0001----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: BX
[/RULE]

[RULE CMN]
- INCLUDE: ----00-10111--------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: CMN
[/RULE]

[RULE CMP]
- INCLUDE: ----00-10101--------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: CMP
[/RULE]

[RULE EOR]
- INCLUDE: ----00-0001---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: EOR
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE LDM_STM]
- INCLUDE: ----100-------------------------
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: LDM_STM
[/RULE]

[RULE LDR]
- INCLUDE: ----01---0-1--------------------
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_2
- COMPONENT: LDR
- COMPONENT: ADDR_WRITEBACK
[/RULE]

[RULE LDRB]
- INCLUDE: ----01---1-1--------------------
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_2
- COMPONENT: LDRB
- COMPONENT: ADDR_WRITEBACK
[/RULE]

[RULE LDRH]
- INCLUDE: ----000----1------------1011----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: LDRH
- COMPONENT: ADDR_WRITEBACK
[/RULE]

[RULE LDRSB]
- INCLUDE: ----000----1------------1101----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: LDRSB
- COMPONENT: ADDR_WRITEBACK
[/RULE]

[RULE LDRSH]
- INCLUDE: ----000----1------------1111----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: LDRSH
- COMPONENT: ADDR_WRITEBACK
[/RULE]

[RULE MUL_MLA]
- INCLUDE: ----000000--------------1001----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: MUL_MLA
[/RULE]

[RULE MOV_MVN]
- INCLUDE: ----00-11-1---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: MOV_MVN
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE MRS]
- INCLUDE: ----00010-00------------0000----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: MRS
[/RULE]

[RULE MSR_IMM]
- INCLUDE: ----00110-10--------------------
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: MSR
[/RULE]

[RULE MSR_REG]
- INCLUDE: ----00010-10--------------------
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: MSR
[/RULE]

[RULE ORR]
- INCLUDE: ----00-1100---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: ORR
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE RSB_RSC_SBC_SUB]
- INCLUDE: ----00-0-1----------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: RSB_RSC_SBC_SUB
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE SMLAL]
- INCLUDE: ----0000111-------------1001----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: SMLAL
[/RULE]

[RULE SMULL]
- INCLUDE: ----0000110-------------1001----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: SMULL
[/RULE]

[RULE STR]
- INCLUDE: ----01---0-0--------------------
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_2
- COMPONENT: STR
- COMPONENT: ADDR_WRITEBACK
[/RULE]

[RULE STRB]
- INCLUDE: ----01---1-0--------------------
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_2
- COMPONENT: STRB
- COMPONENT: ADDR_WRITEBACK
[/RULE]

[RULE STRH]
- INCLUDE: ----000----0------------1011----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: STRH
- COMPONENT: ADDR_WRITEBACK
[/RULE]

[RULE SWI]
- INCLUDE: ----1111------------------------
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: SWI
[/RULE]

[RULE SWP]
- INCLUDE: ----00010000------------1001----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: SWP
[/RULE]

[RULE SWPB]
- INCLUDE: ----00010100------------1001----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: SWPB
[/RULE]

[RULE TEQ]
- INCLUDE: ----00-1001---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: EOR
[/RULE]

[RULE TST]
- INCLUDE: ----00-1000---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: AND
[/RULE]

[RULE UMLAL]
- INCLUDE: ----0000101-------------1001----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: UMLAL
[/RULE]

[RULE UMULL]
- INCLUDE: ----0000100-------------1001----
- COMPONENT: INSTRUCTION_CONDITION
- COMPONENT: UMULL
[/RULE]

[COMPONENT INSTRUCTION_CONDITION]
- FORMAT:  COND----------------------------
{
    @IF(!C !O !N !D) if (!cpu.get_flag_Z()) return;
    @IF(!C !O !N  D) if ( cpu.get_flag_Z()) return;
    @IF(!C !O  N !D) if (!cpu.get_flag_C()) return;
    @IF(!C !O  N  D) if ( cpu.get_flag_C()) return;
    @IF(!C  O !N !D) if (!cpu.get_flag_N()) return;
    @IF(!C  O !N  D) if ( cpu.get_flag_N()) return;
    @IF(!C  O  N !D) if (!cpu.get_flag_V()) return;
    @IF(!C  O  N  D) if ( cpu.get_flag_V()) return;
    @IF( C !O !N !D) if (!cpu.get_flag_C() ||  cpu.get_flag_Z()) return;
    @IF( C !O !N  D) if ( cpu.get_flag_C() && !cpu.get_flag_Z()) return;
    @IF( C !O  N !D) if ( cpu.get_flag_N() !=  cpu.get_flag_V()) return;
    @IF( C !O  N  D) if ( cpu.get_flag_N() ==  cpu.get_flag_V()) return;
    @IF( C  O !N !D) if ( cpu.get_flag_Z() || (cpu.get_flag_N() != cpu.get_flag_V())) return;
    @IF( C  O !N  D) if (!cpu.get_flag_Z() && (cpu.get_flag_N() == cpu.get_flag_V())) return;
    // no checks in the true case (COND == 0xE)
    @IF( C  O  N  D) error("Opcode has COND == 0xF");
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_1]
- FORMAT:  ----001-------------------------
{
    cpu.shifter_operand   = cpu.ROR(get_nth_bits(opcode, 0, 8), cast(ubyte) ((get_nth_bits(opcode, 8, 12)) * 2));
    cpu.shifter_carry_out = get_nth_bits(opcode, 8, 12) == 0 ? cpu.get_flag_C() : get_nth_bit(cpu.shifter_operand, 31);

    _g_cpu_cycles_remaining++;

    int pc_additional_shift_amount = 0;
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_1]
- FORMAT:  ----000------------------SH0----
{
    uint shift_immediate = get_nth_bits(opcode, 7, 12);
    uint rm              = cpu.regs[get_nth_bits(opcode, 0, 4)];

    if (get_nth_bits(opcode, 0, 4) == 15) // are we PC?
        rm += 4;
    
    // S being false and H being false indicates a left shift... sort of. there's a special case when
    // shift_immediate == 0
    @IF(!S !H) if (shift_immediate == 0) {
    @IF(!S !H)     cpu.shifter_operand   = rm;
    @IF(!S !H)     cpu.shifter_carry_out = cpu.get_flag_C();
    @IF(!S !H) } else { // shift_immediate > 0
    @IF(!S !H)     cpu.shifter_operand   = cpu.LSL(rm, cast(ubyte) shift_immediate);
    @IF(!S !H)     cpu.shifter_carry_out = get_nth_bit(rm, 32 - shift_immediate);
    @IF(!S !H) }

    // S being false and H being true indicates a right shift... also sort of. there's a special case when
    // shift_immediate == 0
    @IF(!S  H) if (shift_immediate == 0) {
    @IF(!S  H)     cpu.shifter_operand   = 0;
    @IF(!S  H)     cpu.shifter_carry_out = get_nth_bit(rm, 31);
    @IF(!S  H)     _g_cpu_cycles_remaining--;
    @IF(!S  H) } else { // shift_immediate > 0
    @IF(!S  H)     cpu.shifter_operand   = cpu.LSR(rm, cast(ubyte) shift_immediate);
    @IF(!S  H)     cpu.shifter_carry_out = get_nth_bit(rm, shift_immediate - 1);
    @IF(!S  H) }

    // S being true and H being false indicates an arithmetic shift.
    @IF( S !H) if (shift_immediate == 0) {
    @IF( S !H)     cpu.shifter_operand   = get_nth_bit(rm, 31) ? 0xFFFFFFFF : 0x00000000;
    @IF( S !H)     cpu.shifter_carry_out = get_nth_bit(rm, 31);
    @IF( S !H) } else { // shift_immediate > 0
    @IF( S !H)     cpu.shifter_operand   = cpu.ASR(rm, cast(ubyte) shift_immediate);
    @IF( S !H)     cpu.shifter_carry_out = get_nth_bit(rm, shift_immediate - 1);
    @IF( S !H) }
        
    // S being true and H being true indicates either ROR or RRX, depending on if 
    // shift_immediate is 0
    @IF( S  H) if (shift_immediate == 0) { // RRX
    @IF( S  H)     cpu.shifter_operand   = cpu.get_flag_C() << 31 | cpu.LSR(rm, 1);
    @IF( S  H)     cpu.shifter_carry_out = get_nth_bit(rm, 0); 
    @IF( S  H) } else { // shift_immediate > 0, ROR
    @IF( S  H)     cpu.shifter_operand   = cpu.ROR(rm, cast(ubyte) shift_immediate);
    @IF( S  H)     cpu.shifter_carry_out = get_nth_bit(rm, shift_immediate - 1);
    @IF( S  H) } 

    _g_cpu_cycles_remaining++;

    int pc_additional_shift_amount = 0;
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_1]
- FORMAT:  ----000------------------SH1----
{
    uint rm = cpu.regs[get_nth_bits(opcode, 0, 4)];
    uint rs = get_nth_bits(cpu.regs[get_nth_bits(opcode, 8, 12)], 0, 8);
    
    int pc_additional_shift_amount;
    if (get_nth_bits(opcode, 4, 12) == 0) { 
        if (get_nth_bits(opcode, 0, 4) == 15) // are we PC?
            rm += 4;
        cpu.shifter_operand   = rm;
        cpu.shifter_carry_out = cpu.get_flag_C();
    } else {
        if (get_nth_bits(opcode,  0,  4) == 15) // are we PC?
            rm += 8;
        if (get_nth_bits(opcode,  8, 12) == 15) // are we PC?
            rs += 8;

        if (get_nth_bits(opcode, 16, 20) == 15)
            pc_additional_shift_amount = 4;
        else
            pc_additional_shift_amount = 0;
    }

    // There's a lot of exceptions to the rules here, because rs can be
    // 32 bits long, and that causes some problems. immediate shift had
    // a limit of 5 bits.

    // S being false and H being false indicates a left shift
    @IF(!S !H) if        (rs == 0) {
    @IF(!S !H)     cpu.shifter_operand   = rm;
    @IF(!S !H)     cpu.shifter_carry_out = cpu.get_flag_C();
    @IF(!S !H) } else if (rs < 32) {
    @IF(!S !H)     cpu.shifter_operand   = cpu.LSL(rm, cast(ubyte) rs);
    @IF(!S !H)     cpu.shifter_carry_out = get_nth_bit(rm, 32 - rs);
    @IF(!S !H) } else if (rs == 32) {
    @IF(!S !H)     cpu.shifter_operand   = 0;
    @IF(!S !H)     cpu.shifter_carry_out = get_nth_bit(rm, 0);
    @IF(!S !H) } else if (rs > 32) {
    @IF(!S !H)     cpu.shifter_operand   = 0;
    @IF(!S !H)     cpu.shifter_carry_out = 0;
    @IF(!S !H) }

    // S being false and H being true indicates a right shift
    @IF(!S  H) if        (rs == 0) {
    @IF(!S  H)     cpu.shifter_operand   = rm;
    @IF(!S  H)     cpu.shifter_carry_out = cpu.get_flag_C();
    @IF(!S  H) } else if (rs < 32) {
    @IF(!S  H)     cpu.shifter_operand   = cpu.LSR(rm, cast(ubyte) rs);
    @IF(!S  H)     cpu.shifter_carry_out = get_nth_bit(rm, rs - 1);
    @IF(!S  H) } else if (rs == 32) {
    @IF(!S  H)     cpu.shifter_operand   = 0;
    @IF(!S  H)     cpu.shifter_carry_out = get_nth_bit(rm, 31);
    @IF(!S  H) } else if (rs > 32) {
    @IF(!S  H)     cpu.shifter_operand   = 0;
    @IF(!S  H)     cpu.shifter_carry_out = 0;
    @IF(!S  H) }
        
    // S being true and H being false indicates ASR
    @IF( S !H) if        (rs == 0) {
    @IF( S !H)     cpu.shifter_operand   = rm;
    @IF( S !H)     cpu.shifter_carry_out = cpu.get_flag_C();
    @IF( S !H) } else if (rs < 32) {
    @IF( S !H)     cpu.shifter_operand   = cpu.ASR(rm, cast(ubyte) rs);
    @IF( S !H)     cpu.shifter_carry_out = get_nth_bit(rm, rs - 1);
    @IF( S !H) } else { // rs >= 32
    @IF( S !H)     cpu.shifter_operand   = get_nth_bit(rm, 31) ? 0xFFFFFFFF : 0x00000000;
    @IF( S !H)     cpu.shifter_carry_out = get_nth_bit(rm, 31);
    @IF( S !H) }

    // S and H being true indicates ROR
    @IF( S  H) if        ((rs & 0xFF) == 0) {
    @IF( S  H)     cpu.shifter_operand   = rm;
    @IF( S  H)     cpu.shifter_carry_out = cpu.get_flag_C();
    @IF( S  H) } else if ((rs & 0x1F) == 0) {
    @IF( S  H)     cpu.shifter_operand   = rm;
    @IF( S  H)     cpu.shifter_carry_out = get_nth_bit(rm, 31);
    @IF( S  H) } else { // rs & 0x1F > 0
    @IF( S  H)     cpu.shifter_operand   = cpu.ROR(rm, cast(ubyte) (rs & 0x1F));
    @IF( S  H)     cpu.shifter_carry_out = get_nth_bit(rm, (rs & 0x1F) - 1);
    @IF( S  H) }

    _g_cpu_cycles_remaining++;
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_2]
- FORMAT:  ----010PUBWL--------------------
{
    // NOTE: this is the IMMEDIATE OFFSET part of ADDRESSING_MODE_2
    // also yes it does look very similar to ADDRESSING_MODE_3 but what can I realistically do,
    // this was the way the cpu was designed.
    // actually, this can be made cleaner if i allow components to contain components.... maybe
    // a task for another day.
    uint addr_writeback;
    bool should_writeback = false;
    
    // pc is required to know if we should add an extra offset of 4 to account for the pipeline
    bool is_pc = get_nth_bits(opcode, 16, 20) == 15;

    // this is immediate addressing - so we just get the offset straight from the opcode
    uint offset = get_nth_bits(opcode, 0, 12);

    // U determines if we add or subtract
    // P determines if we're doing post-indexed addressing or not
    @IF( P  U) uint address = cpu.regs[get_nth_bits(opcode, 16, 20)] + offset + (is_pc ? 4 : 0);
    @IF( P !U) uint address = cpu.regs[get_nth_bits(opcode, 16, 20)] - offset + (is_pc ? 4 : 0);
    // @IF( P  W) cpu.regs[get_nth_bits(opcode, 16, 20)] = address;

    @IF(!P   ) uint address = cpu.regs[get_nth_bits(opcode, 16, 20)];
    @IF(!P  U) addr_writeback = cpu.regs[get_nth_bits(opcode, 16, 20)] + offset + (is_pc ? 4 : 0);
    @IF(!P !U) addr_writeback = cpu.regs[get_nth_bits(opcode, 16, 20)] - offset + (is_pc ? 4 : 0);
    @IF(!P   ) should_writeback = true;

    // if the writeback bit is specified, then do a writeback.
    @IF( W) addr_writeback   = address;
    @IF( W) should_writeback = true;
    
    @IF( L) if (get_nth_bits(opcode, 16, 20) == get_nth_bits(opcode, 12, 16)) should_writeback = false;
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_2]
- FORMAT:  ----011PUBWL-------------SH-----
{ 
    uint address = cpu.regs[get_nth_bits(opcode, 16, 20)];
    uint operand = cpu.regs[get_nth_bits(opcode, 0,  4)];
    uint shift_immediate = get_nth_bits(opcode, 7, 12);
    uint addr_writeback;
    bool should_writeback = false;

    uint index = 0;

    // S being false indicates a shift of some type
    @IF(!S !H) index = operand << shift_immediate;

    @IF(!S  H) if (shift_immediate == 0) {
    @IF(!S  H)     index = 0;
    @IF(!S  H) } else {
    @IF(!S  H)     index = operand >> shift_immediate;
    @IF(!S  H) }
    
    // S being true but H being false indicates an arithmetic shift
    @IF( S !H) if (shift_immediate != 0) {
    @IF( S !H)     if ((operand >> 31) == 1) {
    @IF( S !H)         index = (((1 << shift_immediate) - 1) << (32 - shift_immediate)) | (operand >> shift_immediate);
    @IF( S !H)     } else {
    @IF( S !H)         index = operand >> shift_immediate;
    @IF( S !H)     }
    @IF( S !H) }
    @IF( S !H) else index = (get_nth_bit(operand, 31) == 1 ? 0xFFFFFFFF : 0x00000000);

    // S being true and H being true indicates a rotate right or a rotate right with extend.
    @IF( S  H) if (shift_immediate != 0) {
    @IF( S  H)     uint rotated_off = get_nth_bits(operand, 0, shift_immediate);  // the value that is rotated off
    @IF( S  H)     uint rotated_in  = get_nth_bits(operand, shift_immediate, 32); // the value that stays after the rotation
    @IF( S  H)     index = rotated_in | (rotated_off << (32 - shift_immediate));
    @IF( S  H) }
    @IF( S  H) else {
    @IF( S  H)     uint rotated_off = get_nth_bit(cpu.get_flag_C(), 0);      // the value that is rotated off
    @IF( S  H)     uint rotated_in  = get_nth_bits(operand, 1, 32); // the value that stays after the rotation

    @IF( S  H)     index = rotated_in | (rotated_off << 31);
    @IF( S  H) }

     // P bit being set indicates offset addressing or pre-indexed addressing
    @IF( P  U) address += index;
    @IF( P !U) address -= index;
    // @IF( P  W) cpu.regs[get_nth_bits(opcode, 16, 20)] = address;

    @IF( P  W) addr_writeback   = address;
    @IF( P  W) should_writeback = true;
    
    // P bit being clear indicates post-indexed addressing
    @IF(!P  U) addr_writeback   = cpu.regs[get_nth_bits(opcode, 16, 20)] + index;
    @IF(!P !U) addr_writeback   = cpu.regs[get_nth_bits(opcode, 16, 20)] - index;
    @IF(!P   ) should_writeback = true;
    
    if (get_nth_bits(opcode, 16, 20) == 15) { // are we register PC?
        address += 4;
    }

    @IF( L) if (get_nth_bits(opcode, 16, 20) == get_nth_bits(opcode, 12, 16)) should_writeback = false;
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_3]
- FORMAT:  ----00OPUIWL--------------------
{
    // pc is required to know if we should add an extra offset of 4 to account for the pipeline
    bool is_pc = get_nth_bits(opcode, 16, 20) == 15;
    uint addr_writeback;
    bool should_writeback = false;

    // we either get the offset straight from the opcode or from the registers depending on the I bit
    @IF( I) ubyte offset = cast(ubyte)(get_nth_bits(opcode, 0, 4) | (get_nth_bits(opcode, 8, 12) << 4));
    @IF(!I) uint  offset = cpu.regs[get_nth_bits(opcode, 0, 4)];

    // U determines if we add or subtract
    // P determines if we're doing post-indexed addressing or not
    @IF( P  U) uint address = cpu.regs[get_nth_bits(opcode, 16, 20)] + offset + (is_pc ? 4 : 0);
    @IF( P !U) uint address = cpu.regs[get_nth_bits(opcode, 16, 20)] - offset + (is_pc ? 4 : 0);
    // @IF( P  W) cpu.regs[get_nth_bits(opcode, 16, 20)] = address;

    @IF(!P   ) uint address = cpu.regs[get_nth_bits(opcode, 16, 20)];
    @IF(!P  U) addr_writeback = cpu.regs[get_nth_bits(opcode, 16, 20)] + offset + (is_pc ? 4 : 0);
    @IF(!P !U) addr_writeback = cpu.regs[get_nth_bits(opcode, 16, 20)] - offset + (is_pc ? 4 : 0);
    @IF(!P   ) should_writeback = true;

    // if the writeback bit is specified, then do a writeback.
    @IF( W) addr_writeback   = address;
    @IF( W) should_writeback = true;

    @IF( L) if (get_nth_bits(opcode, 16, 20) == get_nth_bits(opcode, 12, 16)) should_writeback = false;
}
[/COMPONENT]

[COMPONENT ADDR_WRITEBACK]
- FORMAT:  -------PUBWL-------------SH-----
{
    if (should_writeback) cpu.regs[get_nth_bits(opcode, 16, 20)] = addr_writeback; 
}
[/COMPONENT]

[COMPONENT DATA_WRITEBACK]
- FORMAT:  ----00I----S--------------------
{
    if (get_nth_bits(opcode, 12, 16) == 15) _g_cpu_cycles_remaining += 2;
    cpu.regs[get_nth_bits(opcode, 12, 16)] = result;
}
[/COMPONENT]

[COMPONENT ADD_ADC]
- FORMAT:  ----00I010CS--------------------
{
    uint old_value        = cpu.regs[get_nth_bits(opcode, 12, 16)];
    uint register_operand = cpu.regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4 + pc_additional_shift_amount;
    
    @IF( C) uint result   = register_operand + cpu.shifter_operand + cpu.get_flag_C();
    @IF(!C) uint result   = register_operand + cpu.shifter_operand;

    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_N(result >> 31);
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S !C)  cpu.set_flag_C((cast(ulong) register_operand + cast(ulong) cpu.shifter_operand)                    >= 0x1_0000_0000);
    @IF( S  C)  cpu.set_flag_C((cast(ulong) register_operand + cast(ulong) cpu.shifter_operand + cpu.get_flag_C()) >= 0x1_0000_0000);
    @IF( S)     cpu.set_flag_V(((register_operand >> 31) == (cpu.shifter_operand >> 31)) && ((register_operand >> 31) ^ (result >> 31)));
    @IF( S) }
}
[/COMPONENT]

[COMPONENT AND]
- FORMAT:  ----00I-000S--------------------
{
    uint register_operand = cpu.regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4 + pc_additional_shift_amount;
    uint result = register_operand & cpu.shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_N(result >> 31);
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_C(cpu.shifter_carry_out);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT BIC]
- FORMAT:  ----00I1110S--------------------
{
    uint register_operand = cpu.regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4 + pc_additional_shift_amount;
    uint result = register_operand & ~cpu.shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_N(result >> 31);
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_C(cpu.shifter_carry_out);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT B_BL]
- FORMAT:  ----101L------------------------
{
    @IF(L) *cpu.lr = *cpu.pc;
    // unintuitive sign extension: http://graphics.stanford.edu/~seander/bithacks.html#FixedSignExtend
    *cpu.pc += ((((1 << 23) ^ get_nth_bits(opcode, 0, 24)) - (1 << 23)) << 2) + 4;

    _g_cpu_cycles_remaining += 3;
}
[/COMPONENT]

[COMPONENT BX]
- FORMAT:  ----00010010------------0001----
{
    cpu.set_bit_T(cpu.regs[get_nth_bits(opcode, 0, 4)] & 0x1);
    *cpu.pc = (cpu.regs[get_nth_bits(opcode, 0, 4)] & 0xFFFFFFFE);
}
[/COMPONENT]

[COMPONENT CMN]
- FORMAT:  ----00I1011S--------------------
{
    uint old_value        = cpu.regs[get_nth_bits(opcode, 12, 16)];
    uint register_operand = cpu.regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4 + pc_additional_shift_amount;
    uint result           = register_operand + cpu.shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_N(result >> 31);
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_V(((register_operand >> 31) == (cpu.shifter_operand >> 31)) && ((register_operand >> 31) ^ (result >> 31)));
    @IF( S)     cpu.set_flag_C((cast(ulong) register_operand + cast(ulong) cpu.shifter_operand) > 0x1_0000_0000);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT CMP]
- FORMAT:  ----00I1010S--------------------
{
    uint old_value        = cpu.regs[get_nth_bits(opcode, 12, 16)];
    uint register_operand = cpu.regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4 + pc_additional_shift_amount;
    uint result           = register_operand + ~cpu.shifter_operand + 1;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_N(result >> 31);
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_V(((register_operand >> 31) ^ (cpu.shifter_operand >> 31)) && ((register_operand >> 31) ^ (result >> 31)));
    @IF( S)     cpu.set_flag_C(register_operand >= cpu.shifter_operand);
    @IF( S) }

    // warning(format("Comparing %x with %x", register_operand, cpu.shifter_operand));
    // warning(format("CMP: %x %x, %x %x", register_operand, cpu.shifter_operand, opcode, *cpu.pc));
}
[/COMPONENT]

[COMPONENT EOR]
- FORMAT:  ----00I-001S--------------------
{
    uint register_operand = cpu.regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4 + pc_additional_shift_amount;
    uint result = register_operand ^ cpu.shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_N(result >> 31);
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_C(cpu.shifter_carry_out);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT LDR]
- FORMAT:  ----01---0-1--------------------
{
    uint value = cpu.memory.read_word(address & 0xFFFFFFFC);
    if ((address & 0b11) == 0b01) value = ((value & 0xFF)     << 24) | (value >> 8);
    if ((address & 0b11) == 0b10) value = ((value & 0xFFFF)   << 16) | (value >> 16);
    if ((address & 0b11) == 0b11) value = ((value & 0xFFFFFF) << 8)  | (value >> 24);

    ubyte rd = cast(ubyte) get_nth_bits(opcode, 12, 16);
    if (rd == 15) {
        *cpu.pc = value & 0xFFFFFFFC;
        _g_cpu_cycles_remaining += 2;
    } else {
        cpu.regs[rd] = value;
    }

    _g_cpu_cycles_remaining += 3;
}
[/COMPONENT]

[COMPONENT LDRB]
- FORMAT:  ----01---1-1--------------------
{
    cpu.regs[get_nth_bits(opcode, 12, 16)] = cpu.memory.read_byte(address);
    if (get_nth_bits(opcode, 12, 16) == 15) _g_cpu_cycles_remaining += 2;
    _g_cpu_cycles_remaining += 3;
}
[/COMPONENT]

[COMPONENT LDRH]
- FORMAT:  ----000----1--------------------
{
    uint value = cpu.memory.read_halfword(address & 0xFFFFFFFE);
    if ((address & 0b11) == 0b01) value = ((value & 0xFF) << 24) | (value >> 8);

    cpu.regs[get_nth_bits(opcode, 12, 16)] = value;
    if (get_nth_bits(opcode, 12, 16) == 15) _g_cpu_cycles_remaining += 2;
    _g_cpu_cycles_remaining += 3;
}
[/COMPONENT]

[COMPONENT LDRSB]
- FORMAT:  ----000----1------------1101----
{
    cpu.regs[get_nth_bits(opcode, 12, 16)] = sign_extend(cpu.memory.read_byte(address), 8);
    if (get_nth_bits(opcode, 12, 16) == 15) _g_cpu_cycles_remaining += 2;
    _g_cpu_cycles_remaining += 3;
}
[/COMPONENT]

[COMPONENT LDRSH]
- FORMAT:  ----000----1------------1111----
{
    uint value = cpu.memory.read_halfword(address & 0xFFFFFFFE);
    if (address & 1) { 
        value = sign_extend(value >> 8, 8);
    } else {
        value = sign_extend(value, 16);
    }

    cpu.regs[get_nth_bits(opcode, 12, 16)] = value;
    if (get_nth_bits(opcode, 12, 16) == 15) _g_cpu_cycles_remaining += 2;
    _g_cpu_cycles_remaining += 3;
}
[/COMPONENT]

[COMPONENT LDM_STM]
- FORMAT:  ----100PUSWL--------------------
{
    // this if statement emulates unpredictable ARM7TDMI behavior
    if (get_nth_bits(opcode, 0, 16) == 0) {
        *cpu.pc += 8; // skip the next instruction
        cpu.regs[get_nth_bits(opcode, 16, 20)] += 4 * 16;
        return;
    }

    uint address = cpu.regs[get_nth_bits(opcode, 16, 20)];

    @IF( U) int mask = 1;
    @IF(!U) int mask = 0x8000; 

    int num_transactions = 0;

    @IF( L) bool pc_loaded   = false;

    @IF( S) bool pc_included = get_nth_bit(opcode, 15);

    bool register_in_rlist = (opcode >> get_nth_bits(opcode, 16, 20)) & 1;

    @IF( U) for (int i = 0;  i <  16; i++) {
    @IF(!U) for (int i = 15; i >= 0;  i--) {

        if (opcode & mask) {
            @IF( P  U) address += 4;
            @IF( P !U) address -= 4;

            @IF(!S  L) cpu.regs[i] = cpu.memory.read_word(address);

            @IF(!S !L) if (i == 15) {
            @IF(!S !L)     cpu.memory.write_word(address, cpu.regs[15] + 8);
            @IF(!S !L) } else {
            @IF(!S !L)     cpu.memory.write_word(address, cpu.regs[i]);
            @IF(!S !L) }

            @IF( S  L) if (pc_included) cpu.regs         [i]                        = cpu.memory.read_word(address);
            @IF( S  L) else             cpu.register_file[cpu.MODE_USER.OFFSET + i] = cpu.memory.read_word(address);

            @IF( S !L) if (i == 15) {
            @IF( S !L)     cpu.memory.write_word(address, cpu.register_file[cpu.MODE_USER.OFFSET + 15] + 8);
            @IF( S !L) } else {
            @IF( S !L)     cpu.memory.write_word(address, cpu.register_file[cpu.MODE_USER.OFFSET + i]);
            @IF( S !L) }

            @IF(!P  U) address += 4;
            @IF(!P !U) address -= 4;

            @IF(L) num_transactions++;

            @IF(L) if (i == 15) pc_loaded = true;
        }

        @IF(U)  mask <<= 1; 
        @IF(!U) mask >>= 1;
    }

    *cpu.pc &= 0xFFFFFFFE;

    @IF( L  S) if (pc_loaded) *cpu.cpsr = *cpu.spsr;

    @IF( L) _g_cpu_cycles_remaining += num_transactions + 2;
    @IF( L) if (pc_loaded) _g_cpu_cycles_remaining += 2;

    @IF(!L) _g_cpu_cycles_remaining += num_transactions + 1;
    
    @IF( W  L) if (!register_in_rlist) cpu.regs[get_nth_bits(opcode, 16, 20)] = address;
    @IF( W !L) cpu.regs[get_nth_bits(opcode, 16, 20)] = address;
}
[/COMPONENT]

[COMPONENT MOV_MVN]
- FORMAT:  ----00I11N1S--------------------
{
    @IF( N) uint result = ~cpu.shifter_operand;
    @IF(!N) uint result =  cpu.shifter_operand;

    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_N(result >> 31);
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_C(cpu.shifter_carry_out);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT MRS]
- FORMAT:  ----00010R00------------0000----
{
    @IF(!R) cpu.regs[get_nth_bits(opcode, 12, 16)] = *cpu.cpsr;
    @IF( R) cpu.regs[get_nth_bits(opcode, 12, 16)] = *cpu.spsr;

    _g_cpu_cycles_remaining++;
}
[/COMPONENT]

[COMPONENT MSR]
- FORMAT:  ----00I10R10--------------------
{
    @IF( I) uint  operand     = cpu.ROR(get_nth_bits(opcode, 0, 8), cast(ubyte) (get_nth_bits(opcode, 8, 12) * 2));
    @IF(!I) uint  operand     = cpu.regs[get_nth_bits(opcode, 0, 4)];

    @IF( R) uint* destination = cpu.spsr;
    @IF(!R) uint* destination = cpu.cpsr;

    if (get_nth_bit(opcode, 16)) *destination = (*destination & 0xFFFFFF00) | (operand & 0x000000FF);
    if (get_nth_bit(opcode, 17)) *destination = (*destination & 0xFFFF00FF) | (operand & 0x0000FF00);
    if (get_nth_bit(opcode, 18)) *destination = (*destination & 0xFF00FFFF) | (operand & 0x00FF0000);
    if (get_nth_bit(opcode, 19)) *destination = (*destination & 0x00FFFFFF) | (operand & 0xFF000000);

    @IF(!R) cpu.update_mode();
    _g_cpu_cycles_remaining++;
}
[/COMPONENT]

[COMPONENT MUL_MLA]
- FORMAT:  ----000000AS------------1001----
{
    uint* result = &cpu.regs[get_nth_bits(opcode, 16, 20)];
    @IF( A) *result = cpu.regs[get_nth_bits(opcode, 0, 4)] * cpu.regs[get_nth_bits(opcode, 8, 12)] + cpu.regs[get_nth_bits(opcode, 12, 16)];
    @IF(!A) *result = cpu.regs[get_nth_bits(opcode, 0, 4)] * cpu.regs[get_nth_bits(opcode, 8, 12)];

    @IF( S) cpu.set_flag_Z(*result == 0);
    @IF( S) cpu.set_flag_N(*result >> 31);
    
    int m = 4;
    int operand = cpu.regs[get_nth_bits(opcode, 8, 12)];
    if ((operand & 0xFFFFFF00) == 0x000000000 || (operand | 0x000000FF) == 0xFFFFFFFF) m = 1;
    if ((operand & 0xFFFF0000) == 0x000000000 || (operand | 0x0000FFFF) == 0xFFFFFFFF) m = 2;
    if ((operand & 0xFF000000) == 0x000000000 || (operand | 0x00FFFFFF) == 0xFFFFFFFF) m = 3;
    @IF( A) _g_cpu_cycles_remaining += m + 2;
    @IF(!A) _g_cpu_cycles_remaining += m + 1;
}
[/COMPONENT]

[COMPONENT ORR]
- FORMAT:  ----00I1100S--------------------
{
    uint register_operand = cpu.regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4 + pc_additional_shift_amount;
    uint result = register_operand| cpu.shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_N(result >> 31);
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_C(cpu.shifter_carry_out);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT RSB_RSC_SBC_SUB]
- FORMAT:  ----00I0C1RS--------------------
{
    uint register_operand = cpu.regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4 + pc_additional_shift_amount;
    @IF( R) uint result   = cpu.shifter_operand - register_operand;
    @IF(!R) uint result   = register_operand - cpu.shifter_operand;
    @IF( C)  result -= ((~(cast(uint)cpu.get_flag_C())) & 1);

    cpu.regs[get_nth_bits(opcode, 12, 16)] = result;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    // @IF( S)     warning(format("Syncing CPSR... Returning from interrupt. %x", *cpu.spsr));
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();    
    @IF( S) } else {
    @IF( S)     cpu.set_flag_N(result >> 31);
    @IF( S)     cpu.set_flag_Z(result == 0);
    
    @IF( S  R !C)  cpu.set_flag_C((cpu.shifter_operand >= register_operand));
    @IF( S  R !C)  cpu.set_flag_V(((register_operand >> 31) ^ (cpu.shifter_operand >> 31)) && ((register_operand >> 31) == (result >> 31)));
    @IF( S !R !C)  cpu.set_flag_C((cpu.shifter_operand <= register_operand));
    @IF( S !R !C)  cpu.set_flag_V(((cpu.shifter_operand >> 31) ^ (register_operand >> 31)) && ((cpu.shifter_operand >> 31) == (result >> 31)));
    
    @IF( S  R  C)  cpu.set_flag_C((cpu.shifter_operand >= cast(ulong) register_operand + cast(ulong) ((~(cast(uint)cpu.get_flag_C())) & 1)));
    @IF( S  R  C)  cpu.set_flag_V(((register_operand >> 31) ^ (cpu.shifter_operand >> 31)) && ((register_operand >> 31) == (result >> 31)));
    @IF( S !R  C)  cpu.set_flag_C((cast(ulong) cpu.shifter_operand + cast(ulong) ((~(cast(uint)cpu.get_flag_C())) & 1) <= register_operand));
    @IF( S !R  C)  cpu.set_flag_V(((cpu.shifter_operand >> 31) ^ (register_operand >> 31)) && ((cpu.shifter_operand >> 31) == (result >> 31)));
    
    @IF( S) }
}
[/COMPONENT]

[COMPONENT SMLAL]
- FORMAT:  ----0000111S------------1001----
{
    // unintuitive sign extension 
    // http://graphics.stanford.edu/~seander/bithacks.html#FixedSignExtend
    const ulong mask = 1U << (32 - 1);

    ulong result = (((cast(long) cpu.regs[get_nth_bits(opcode, 0, 4)])  ^ mask) - mask) * 
                        (((cast(long) cpu.regs[get_nth_bits(opcode, 8, 12)]) ^ mask) - mask);
    uint* rd_lo = &cpu.regs[get_nth_bits(opcode, 12, 16)];
    uint* rd_hi = &cpu.regs[get_nth_bits(opcode, 16, 20)];

    result += ((cast(ulong) *rd_hi) << 32) | (cast(ulong) *rd_lo);
    *rd_lo = cast(uint) (result & 0xFFFFFFFF);
    *rd_hi = cast(uint) (result >> 32);
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_N(result >> 63);
    @IF( S) }

    int m = 4;
    int operand = cast(int) (((cast(long) cpu.regs[get_nth_bits(opcode, 8, 12)]) ^ mask) - mask);
    if ((operand & 0xFFFFFF00) == 0x000000000 || (operand | 0x000000FF) == 0xFFFFFFFF) m = 1;
    if ((operand & 0xFFFF0000) == 0x000000000 || (operand | 0x0000FFFF) == 0xFFFFFFFF) m = 2;
    if ((operand & 0xFF000000) == 0x000000000 || (operand | 0x00FFFFFF) == 0xFFFFFFFF) m = 3;
    _g_cpu_cycles_remaining += m + 3;
}
[/COMPONENT]

[COMPONENT SMULL]
- FORMAT:  ----0000110S------------1001----
{
    // unintuitive sign extension 
    // http://graphics.stanford.edu/~seander/bithacks.html#FixedSignExtend
    const ulong mask = 1U << (32 - 1);

    ulong result = (((cast(long) cpu.regs[get_nth_bits(opcode, 0, 4)])  ^ mask) - mask) * 
                      (((cast(long) cpu.regs[get_nth_bits(opcode, 8, 12)]) ^ mask) - mask);

    cpu.regs[get_nth_bits(opcode, 12, 16)] = cast(uint) (result & 0xFFFFFFFF);
    cpu.regs[get_nth_bits(opcode, 16, 20)] = cast(uint) (result >> 32);

    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_N(result >> 63);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT STR]
- FORMAT:  ----01IPU0W0--------------------
{
    uint result = cpu.regs[get_nth_bits(opcode, 12, 16)];
    if (get_nth_bits(opcode, 12, 16) == 15) result += 8;
    cpu.memory.write_word(address & 0xFFFFFFFC, result);
    _g_cpu_cycles_remaining += 2;
}
[/COMPONENT]

[COMPONENT STRB]
- FORMAT:  ----01IPU1W0--------------------
{
    uint result = cpu.regs[get_nth_bits(opcode, 12, 16)];
    if (get_nth_bits(opcode, 12, 16) == 15) result += 8;
    cpu.memory.write_byte(address, result & 0xFF);
    _g_cpu_cycles_remaining += 2;
}
[/COMPONENT]

[COMPONENT STRH]
- FORMAT:  ----000PUIW0------------1011----
{
    cpu.memory.write_halfword(address & ~1, cpu.regs[get_nth_bits(opcode, 12, 16)] & 0xFFFF);
    _g_cpu_cycles_remaining += 2;
}
[/COMPONENT]

[COMPONENT SWI]
- FORMAT:  ----1111------------------------
{
    warning(format("SWI: %x", opcode));
    cpu.exception(CpuException.SoftwareInterrupt);
}
[/COMPONENT]

[COMPONENT SWP]
- FORMAT:  ----00010000------------1001----
{
    uint address = cpu.regs[get_nth_bits(opcode, 16, 20)];
    uint value   = cpu.memory.read_word(address & 0xFFFFFFFC);
    if ((address & 0b11) == 0b01) value = ((value & 0xFF)     << 24) | (value >> 8);
    if ((address & 0b11) == 0b10) value = ((value & 0xFFFF)   << 16) | (value >> 16);
    if ((address & 0b11) == 0b11) value = ((value & 0xFFFFFF) << 8)  | (value >> 24);
    
    cpu.memory.write_word(address & 0xFFFFFFFC, cpu.regs[get_nth_bits(opcode, 0, 4)]);
    cpu.regs[get_nth_bits(opcode, 12, 16)] = value;

    _g_cpu_cycles_remaining += 4;
}
[/COMPONENT]

[COMPONENT SWPB]
- FORMAT: ----00010100------------1001----
{
    uint temp = cpu.memory.read_byte(cpu.regs[get_nth_bits(opcode, 16, 20)]);
    cpu.memory.write_byte(cpu.regs[get_nth_bits(opcode, 16, 20)], cpu.regs[get_nth_bits(opcode, 0, 4)] & 0xFF);
    cpu.regs[get_nth_bits(opcode, 12, 16)] = temp;
}
[/COMPONENT]

[COMPONENT UMLAL]
- FORMAT:  ----0000101S------------1001----
{
    ulong result = (cast(ulong) cpu.regs[get_nth_bits(opcode, 0, 4)]) * 
                      (cast(ulong) cpu.regs[get_nth_bits(opcode, 8, 12)]);
    uint* rd_lo = &cpu.regs[get_nth_bits(opcode, 12, 16)];
    uint* rd_hi = &cpu.regs[get_nth_bits(opcode, 16, 20)];

    result += ((cast(ulong) *rd_hi) << 32) | (cast(ulong) *rd_lo);
    *rd_lo = cast(uint) (result & 0xFFFFFFFF);
    *rd_hi = cast(uint) (result >> 32);
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_N(result >> 63);
    @IF( S) }

    int m = 4;
    int operand = (cast(ulong) cpu.regs[get_nth_bits(opcode, 8, 12)]);
    if ((operand & 0xFFFFFF00) == 0x000000000 || (operand | 0x000000FF) == 0xFFFFFFFF) m = 1;
    if ((operand & 0xFFFF0000) == 0x000000000 || (operand | 0x0000FFFF) == 0xFFFFFFFF) m = 2;
    if ((operand & 0xFF000000) == 0x000000000 || (operand | 0x00FFFFFF) == 0xFFFFFFFF) m = 3;
    _g_cpu_cycles_remaining += m + 3;
}
[/COMPONENT]

[COMPONENT UMULL]
- FORMAT:  ----0000100S------------1001----
{
    ulong result = (cast(ulong) cpu.regs[get_nth_bits(opcode, 0, 4)]) * 
                      (cast(ulong) cpu.regs[get_nth_bits(opcode, 8, 12)]);

    cpu.regs[get_nth_bits(opcode, 12, 16)] = cast(uint) (result & 0xFFFFFFFF);
    cpu.regs[get_nth_bits(opcode, 16, 20)] = cast(uint) (result >> 32);

    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     *cpu.cpsr = *cpu.spsr;
    @IF( S)     cpu.update_mode();
    @IF( S) } else {
    @IF( S)     cpu.set_flag_Z(result == 0);
    @IF( S)     cpu.set_flag_N(result >> 63);
    @IF( S) }
}
[/COMPONENT]