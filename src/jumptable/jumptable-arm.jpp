[SETTINGS]
- NAMESPACE: arm
- OPCODE_FORMAT: IIIIIIIIIIII------------DDDD----
- INCLUDES: iostream ../util.h ../arm7tdmi.h
- ARGUMENTS: ARM7TDMI* cpu
[/SETTINGS]

[DEFAULT]
{
    error("No implementation for opcode 0x" + to_hex_string(opcode));
}
[/DEFAULT]

[RULE ADD_ADC]
- INCLUDE: ----00-010----------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: ADD_ADC
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE AND]
- INCLUDE: ----00-0000---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: AND
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE BIC]
- INCLUDE: ----00-1110---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: BIC
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE B_BL]
- INCLUDE: ----101-------------------------
- COMPONENT: B_BL
[/RULE]

[RULE BX]
- INCLUDE: ----00010010------------0001----
- COMPONENT: BX
[/RULE]

[RULE CMN]
- INCLUDE: ----00-10111--------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: CMN
[/RULE]

[RULE CMP]
- INCLUDE: ----00-10101--------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: CMP
[/RULE]

[RULE EOR]
- INCLUDE: ----00-0001---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: EOR
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE LDM1_STM1]
- INCLUDE: ----100--0----------------------
- COMPONENT: LDM1_STM1
[/RULE]

[RULE LDR]
- INCLUDE: ----01---0-1--------------------
- COMPONENT: ADDRESSING_MODE_2
- COMPONENT: LDR
[/RULE]

[RULE LDRB]
- INCLUDE: ----01---1-1--------------------
- COMPONENT: ADDRESSING_MODE_2
- COMPONENT: LDRB
[/RULE]

[RULE LDRH]
- INCLUDE: ----000----1------------1011----
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: LDRH
[/RULE]

[RULE LDRSB]
- INCLUDE: ----000----1------------1101----
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: LDRSB
[/RULE]

[RULE LDRSH]
- INCLUDE: ----000----1------------1111----
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: LDRSH
[/RULE]

[RULE MUL_MLA]
- INCLUDE: ----000000--------------1001----
- COMPONENT: MUL_MLA
[/RULE]

[RULE MOV_MVN]
- INCLUDE: ----00-11-1---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: MOV_MVN
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE MRS]
- INCLUDE: ----00010-00------------0000----
- COMPONENT: MRS
[/RULE]

[RULE MSR_IMM]
- INCLUDE: ----00110-10--------------------
- COMPONENT: MSR
[/RULE]

[RULE MSR_REG]
- INCLUDE: ----00010-10--------------------
- COMPONENT: MSR
[/RULE]

[RULE ORR]
- INCLUDE: ----00-1100---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: ORR
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE RSB_RSC_SBC_SUB]
- INCLUDE: ----00-0-1----------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: RSB_RSC_SBC_SUB
- COMPONENT: DATA_WRITEBACK
[/RULE]

[RULE SMLAL]
- INCLUDE: ----0000111-------------1001----
- COMPONENT: SMLAL
[/RULE]

[RULE SMULL]
- INCLUDE: ----0000110-------------1001----
- COMPONENT: SMULL
[/RULE]

[RULE STR]
- INCLUDE: ----01---0-0--------------------
- COMPONENT: ADDRESSING_MODE_2
- COMPONENT: STR
[/RULE]

[RULE STRB]
- INCLUDE: ----01---1-0--------------------
- COMPONENT: ADDRESSING_MODE_2
- COMPONENT: STRB
[/RULE]

[RULE STRH]
- INCLUDE: ----000----0------------1011----
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: STRH
[/RULE]

[RULE SWP]
- INCLUDE: ----00010000------------1001----
- COMPONENT: SWP
[/RULE]

[RULE SWPB]
- INCLUDE: ----00010100------------1001----
- COMPONENT: SWPB
[/RULE]

[RULE TEQ]
- INCLUDE: ----00-1001---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: EOR
[/RULE]

[RULE TST]
- INCLUDE: ----00-1000---------------------
- EXCLUDE: ------0-----------------1--1----
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: AND
[/RULE]

[RULE UMLAL]
- INCLUDE: ----0000101-------------1001----
- COMPONENT: UMLAL
[/RULE]

[RULE UMULL]
- INCLUDE: ----0000100-------------1001----
- COMPONENT: UMULL
[/RULE]

[COMPONENT ADDRESSING_MODE_1]
- FORMAT:  ----001-------------------------
{
    cpu->shifter_operand   = cpu->ROR(get_nth_bits(opcode, 0, 8), ((get_nth_bits(opcode, 8, 12)) * 2));
    cpu->shifter_carry_out = get_nth_bits(opcode, 8, 12) == 0 ? cpu->get_flag_C() : get_nth_bit(cpu->shifter_operand, 31);
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_1]
- FORMAT:  ----000------------------SH0----
{
    uint32_t shift_immediate = get_nth_bits(opcode, 7, 12);
    uint32_t rm              = cpu->regs[get_nth_bits(opcode, 0, 4)];

    if (get_nth_bits(opcode, 0, 4) == 15) // are we PC?
        rm += 4;
    
    // S being false and H being false indicates a left shift... sort of. there's a special case when
    // shift_immediate == 0
    @IF(!S !H) if (shift_immediate == 0) {
    @IF(!S !H)     cpu->shifter_operand   = rm;
    @IF(!S !H)     cpu->shifter_carry_out = cpu->get_flag_C();
    @IF(!S !H) } else { // shift_immediate > 0
    @IF(!S !H)     cpu->shifter_operand   = cpu->LSL(rm, shift_immediate);
    @IF(!S !H)     cpu->shifter_carry_out = get_nth_bit(rm, 32 - shift_immediate);
    @IF(!S !H) }

    // S being false and H being true indicates a right shift... also sort of. there's a special case when
    // shift_immediate == 0
    @IF(!S  H) if (shift_immediate == 0) {
    @IF(!S  H)     cpu->shifter_operand   = 0;
    @IF(!S  H)     cpu->shifter_carry_out = get_nth_bit(rm, 31);
    @IF(!S  H) } else { // shift_immediate > 0
    @IF(!S  H)     cpu->shifter_operand   = cpu->LSR(rm, shift_immediate);
    @IF(!S  H)     cpu->shifter_carry_out = get_nth_bit(rm, shift_immediate - 1);
    @IF(!S  H) }

    // S being true and H being false indicates an arithmetic shift.
    @IF( S !H) if (shift_immediate == 0) {
    @IF( S !H)     cpu->shifter_operand   = get_nth_bit(rm, 31) ? 0xFFFFFFFF : 0x00000000;
    @IF( S !H)     cpu->shifter_carry_out = get_nth_bit(rm, 31);
    @IF( S !H) } else { // shift_immediate > 0
    @IF( S !H)     cpu->shifter_operand   = cpu->ASR(rm, shift_immediate);
    @IF( S !H)     cpu->shifter_carry_out = get_nth_bit(rm, shift_immediate - 1);
    @IF( S !H) }
        
    // S being true and H being true indicates either RO or RRX, depending on if 
    // shift_immediate is 0
    @IF( S  H) if (shift_immediate == 0) { // RRX
    @IF( S  H)     cpu->shifter_operand   = cpu->get_flag_C() << 31 | cpu->LSR(rm, 1);
    @IF( S  H)     cpu->shifter_carry_out = get_nth_bit(rm, 0); 
    @IF( S  H) } else { // shift_immediate > 0, ROR
    @IF( S  H)     cpu->shifter_operand   = cpu->ROR(rm, shift_immediate);
    @IF( S  H)     cpu->shifter_carry_out = get_nth_bit(rm, shift_immediate - 1);
    @IF( S  H) }
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_1]
- FORMAT:  ----000------------------SH1----
{
    uint32_t rm = cpu->regs[get_nth_bits(opcode, 0, 4)];
    uint32_t rs = get_nth_bits(cpu->regs[get_nth_bits(opcode, 8, 12)], 0, 8);
    
    if (get_nth_bits(opcode, 4, 12) == 0) { 
        if (get_nth_bits(opcode, 0, 4) == 15) // are we PC?
            rm += 4;

        cpu->shifter_operand   = rm;
        cpu->shifter_carry_out = cpu->get_flag_C();
    }

    // There's a lot of exceptions to the rules here, because rs can be
    // 32 bits long, and that causes some problems. immediate shift had
    // a limit of 5 bits.

    // S being false and H being false indicates a left shift
    @IF(!S !H) if        (rs == 0) {
    @IF(!S !H)     cpu->shifter_operand   = rm;
    @IF(!S !H)     cpu->shifter_carry_out = cpu->get_flag_C();
    @IF(!S !H) } else if (rs < 32) {
    @IF(!S !H)     cpu->shifter_operand   = cpu->LSL(rm, rs);
    @IF(!S !H)     cpu->shifter_carry_out = get_nth_bit(rm, 32 - rs);
    @IF(!S !H) } else if (rs == 32) {
    @IF(!S !H)     cpu->shifter_operand   = 0;
    @IF(!S !H)     cpu->shifter_carry_out = get_nth_bit(rm, 0);
    @IF(!S !H) } else if (rs > 32) {
    @IF(!S !H)     cpu->shifter_operand   = 0;
    @IF(!S !H)     cpu->shifter_carry_out = 0;
    @IF(!S !H) }

    // S being false and H being true indicates a right shift
    @IF(!S  H) if        (rs == 0) {
    @IF(!S  H)     cpu->shifter_operand   = rm;
    @IF(!S  H)     cpu->shifter_carry_out = cpu->get_flag_C();
    @IF(!S  H) } else if (rs < 32) {
    @IF(!S  H)     cpu->shifter_operand   = cpu->LSR(rm, rs);
    @IF(!S  H)     cpu->shifter_carry_out = get_nth_bit(rm, rs - 1);
    @IF(!S  H) } else if (rs == 32) {
    @IF(!S  H)     cpu->shifter_operand   = 0;
    @IF(!S  H)     cpu->shifter_carry_out = get_nth_bit(rm, 31);
    @IF(!S  H) } else if (rs > 32) {
    @IF(!S  H)     cpu->shifter_operand   = 0;
    @IF(!S  H)     cpu->shifter_carry_out = 0;
    @IF(!S  H) }
        
    // S being true and H being false indicates ASR
    @IF( S !H) if        (rs == 0) {
    @IF( S !H)     cpu->shifter_operand   = rm;
    @IF( S !H)     cpu->shifter_carry_out = cpu->get_flag_C();
    @IF( S !H) } else if (rs < 32) {
    @IF( S !H)     cpu->shifter_operand   = cpu->ASR(rm, rs);
    @IF( S !H)     cpu->shifter_carry_out = get_nth_bit(rm, rs - 1);
    @IF( S !H) } else { // rs >= 32
    @IF( S !H)     cpu->shifter_operand   = get_nth_bit(rm, 31) ? 0xFFFFFFFF : 0x00000000;
    @IF( S !H)     cpu->shifter_carry_out = get_nth_bit(rm, 0);
    @IF( S !H) }

    // S and H being true indicates ROR
    @IF( S  H) if        (rs == 0) {
    @IF( S  H)     cpu->shifter_operand   = rm;
    @IF( S  H)     cpu->shifter_carry_out = cpu->get_flag_C();
    @IF( S  H) } else if ((rs & 0xF) == 0) {
    @IF( S  H)     cpu->shifter_operand   = rm;
    @IF( S  H)     cpu->shifter_carry_out = get_nth_bit(rm, 31);
    @IF( S  H) } else { // rs & 0xF > 0
    @IF( S  H)     cpu->shifter_operand   = cpu->ROR(rm, rs & 0xF);
    @IF( S  H)     cpu->shifter_carry_out = get_nth_bit(rs, rm & 0xF - 1);
    @IF( S  H) }
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_2]
- FORMAT:  ----010PUBWL--------------------
{
    // NOTE: this is the IMMEDIATE OFFSET part of ADDRESSING_MODE_2
    // also yes it does look very similar to ADDRESSING_MODE_3 but what can I realistically do,
    // this was the way the cpu was designed.
    // actually, this can be made cleaner if i allow components to contain components.... maybe
    // a task for another day.
    
    // pc is required to know if we should add an extra offset of 4 to account for the pipeline
    bool is_pc = get_nth_bits(opcode, 16, 20) == 15;

    // this is immediate addressing - so we just get the offset straight from the opcode
    uint32_t offset = get_nth_bits(opcode, 0, 12);

    // U determines if we add or subtract
    // O determines if we're doing post-indexed addressing or not
    @IF( P  U) uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)] + offset + (is_pc ? 4 : 0);
    @IF( P !U) uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)] - offset + (is_pc ? 4 : 0);

    @IF(!P)    uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)];
    @IF(!P  U) cpu->regs[get_nth_bits(opcode, 16, 20)] += offset + (is_pc ? 4 : 0);
    @IF(!P !U) cpu->regs[get_nth_bits(opcode, 16, 20)] -= offset + (is_pc ? 4 : 0);

    // if the writeback bit is specified, then do a writeback.
    @IF( W) cpu->regs[get_nth_bits(opcode, 16, 20)] = address;
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_2]
- FORMAT:  ----011PUBWL-------------SH-----
{
    uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)];
    uint32_t operand = cpu->regs[get_nth_bits(opcode, 0,  4)];
    uint32_t shift_immediate = get_nth_bits(opcode, 7, 12);

    uint32_t index = 0;

    // S being false indicates a shift of some type
    @IF(!S !H) index = operand << shift_immediate;
    @IF(!S  H) index = operand >> shift_immediate;

    // S being true but H being false indicates an arithmetic shift
    @IF( S !H) if (shift_immediate != 0) {
    @IF( S !H)     if ((operand >> 31) == 1) {
    @IF( S !H)         index = (((1 << shift_immediate) - 1) << (32 - shift_immediate)) | (operand >> shift_immediate);
    @IF( S !H)     } else {
    @IF( S !H)         index = operand >> shift_immediate;
    @IF( S !H)     }
    @IF( S !H) }
    @IF( S !H) else index = (get_nth_bit(shift_immediate, 31) == 1 ? 0xFFFFFFFF : 0x00000000);

    // S being true and H being true indicates a rotate right or a rotate right with extend.
    @IF( S  H) if (shift_immediate != 0) {
    @IF( S  H)     uint32_t rotated_off = get_nth_bits(operand, 0, shift_immediate);  // the value that is rotated off
    @IF( S  H)     uint32_t rotated_in  = get_nth_bits(operand, shift_immediate, 32); // the value that stays after the rotation
    @IF( S  H)     index = rotated_in | (rotated_off << (32 - shift_immediate));
    @IF( S  H) }
    @IF( S  H) else {
    @IF( S  H)     uint32_t rotated_off = get_nth_bit(operand, 0);      // the value that is rotated off
    @IF( S  H)     uint32_t rotated_in  = get_nth_bits(operand, 1, 32); // the value that stays after the rotation

    @IF( S  H)     index = rotated_in | (rotated_off << 31);
    @IF( S  H)     cpu->set_flag_C(get_nth_bit(operand, shift_immediate));
    @IF( S  H) }

     // P bit being set indicates offset addressing or pre-indexed addressing
    @IF( P  U) address += index;
    @IF( P !U) address -= index;

    @IF( P  W) cpu->regs[get_nth_bits(opcode, 16, 20)] = address;
    
    // P bit being clear indicates post-indexed addressing
    @IF(!P  U) cpu->regs[get_nth_bits(opcode, 16, 20)] += index;
    @IF(!P !U) cpu->regs[get_nth_bits(opcode, 16, 20)] -= index;
    
    if (get_nth_bits(opcode, 16, 20) == 15) { // are we register PC?
        address += 4;
    }
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_3]
- FORMAT:  ----00OPUIWL--------------------
{
    // pc is required to know if we should add an extra offset of 4 to account for the pipeline
    bool is_pc = get_nth_bits(opcode, 16, 20) == 15;

    // we either get the offset straight from the opcode or from the registers depending on the I bit
    @IF( I) uint8_t  offset = get_nth_bits(opcode, 0, 4) | (get_nth_bits(opcode, 8, 12) << 4);
    @IF(!I) uint32_t offset = cpu->regs[get_nth_bits(opcode, 0, 4)];

    // U determines if we add or subtract
    // P determines if we're doing post-indexed addressing or not
    @IF( P  U) uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)] + offset + (is_pc ? 4 : 0);
    @IF( P !U) uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)] - offset + (is_pc ? 4 : 0);

    @IF(!P)    uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)];
    @IF(!P  U) cpu->regs[get_nth_bits(opcode, 16, 20)] += offset + (is_pc ? 4 : 0);
    @IF(!P !U) cpu->regs[get_nth_bits(opcode, 16, 20)] -= offset + (is_pc ? 4 : 0);

    // if the writeback bit is specified, then do a writeback.
    @IF( W) cpu->regs[get_nth_bits(opcode, 16, 20)] = address;
}
[/COMPONENT]

[COMPONENT DATA_WRITEBACK]
- FORMAT:  ----00I----S--------------------
{
    cpu->regs[get_nth_bits(opcode, 12, 16)] = result;
}
[/COMPONENT]

[COMPONENT ADD_ADC]
- FORMAT:  ----00I010CS--------------------
{
    uint32_t old_value        = cpu->regs[get_nth_bits(opcode, 12, 16)];
    uint32_t register_operand = cpu->regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4;
    
    @IF( C) uint32_t result   = register_operand + cpu->shifter_operand + cpu->get_flag_C();
    @IF(!C) uint32_t result   = register_operand + cpu->shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_N(result >> 31);
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S)     cpu->set_flag_C(((register_operand >> 31) || (cpu->shifter_operand >> 31)) && !(result >> 31));
    @IF( S)     cpu->set_flag_V(((register_operand >> 31) == (cpu->shifter_operand >> 31)) && ((register_operand >> 31) ^ (result >> 31)));
    @IF( S) }
}
[/COMPONENT]

[COMPONENT AND]
- FORMAT:  ----00I-000S--------------------
{
    uint32_t register_operand = cpu->regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4;
    uint32_t result = register_operand & cpu->shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_N(result >> 31);
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT BIC]
- FORMAT:  ----00I1110S--------------------
{
    uint32_t register_operand = cpu->regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4;
    uint32_t result = register_operand & ~cpu->shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_N(result >> 31);
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT B_BL]
- FORMAT:  ----101L------------------------
{
    @IF(L) *cpu->lr = *cpu->pc;
    // unintuitive sign extension: http://graphics.stanford.edu/~seander/bithacks.html#FixedSignExtend
    *cpu->pc += ((((1U << 23) ^ get_nth_bits(opcode, 0, 24)) - (1U << 23)) << 2) + 4;
}
[/COMPONENT]

[COMPONENT BX]
- FORMAT:  ----00010010------------0001----
{
    cpu->set_bit_T(cpu->regs[get_nth_bits(opcode, 0, 4)] & 0x1);
    *cpu->pc = (cpu->regs[get_nth_bits(opcode, 0, 4)] & 0xFFFFFFFE);
}
[/COMPONENT]

[COMPONENT CMN]
- FORMAT:  ----00I1011S--------------------
{
    uint32_t old_value        = cpu->regs[get_nth_bits(opcode, 12, 16)];
    uint32_t register_operand = cpu->regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4;
    uint32_t result           = register_operand + cpu->shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_N(result >> 31);
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S)     cpu->set_flag_V(((register_operand >> 31) == (cpu->shifter_operand >> 31)) && ((register_operand >> 31) ^ (result >> 31)));
    @IF( S)     cpu->set_flag_C(((register_operand >> 31) || (cpu->shifter_operand >> 31)) && !(result >> 31));
    @IF( S) }
}
[/COMPONENT]

[COMPONENT CMP]
- FORMAT:  ----00I1010S--------------------
{
    uint32_t old_value        = cpu->regs[get_nth_bits(opcode, 12, 16)];
    uint32_t register_operand = cpu->regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4;
    uint32_t result           = register_operand + ~cpu->shifter_operand + 1;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_N(result >> 31);
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S)     cpu->set_flag_V(((register_operand >> 31) ^ (cpu->shifter_operand >> 31)) && ((register_operand >> 31) ^ (result >> 31)));
    @IF( S)     cpu->set_flag_C(register_operand >= cpu->shifter_operand);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT EOR]
- FORMAT:  ----00I-001S--------------------
{
    uint32_t register_operand = cpu->regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4;
    uint32_t result = register_operand ^ cpu->shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_N(result >> 31);
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S)     cpu->set_flag_C(cpu->shifter_carry_out);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT LDR]
- FORMAT:  ----01---0-1--------------------
{
    uint32_t value = cpu->memory->read_word(address & 0xFFFFFFFC);
    if ((address & 0b11) == 0b01) value = ((value & 0xFF)     << 24) | (value >> 8);
    if ((address & 0b11) == 0b10) value = ((value & 0xFFFF)   << 16) | (value >> 16);
    if ((address & 0b11) == 0b11) value = ((value & 0xFFFFFF) << 8)  | (value >> 24);

    uint8_t rd = get_nth_bits(opcode, 12, 16);
    if (rd == 15) {
        *cpu->pc = value & 0xFFFFFFFC;
    } else {
        cpu->regs[rd] = value;
    }
}
[/COMPONENT]

[COMPONENT LDRB]
- FORMAT:  ----01---1-1--------------------
{
    cpu->regs[get_nth_bits(opcode, 12, 16)] = cpu->memory->read_byte(address);
}
[/COMPONENT]

[COMPONENT LDRH]
- FORMAT:  ----000----1--------------------
{
    cpu->regs[get_nth_bits(opcode, 12, 16)] = cpu->memory->read_halfword(address);
}
[/COMPONENT]

[COMPONENT LDRSB]
- FORMAT:  ----000----1------------1101----
{
    cpu->regs[get_nth_bits(opcode, 12, 16)] = sign_extend(cpu->memory->read_byte(address), 8);
}
[/COMPONENT]

[COMPONENT LDRSH]
- FORMAT:  ----000----1------------1111----
{
    cpu->regs[get_nth_bits(opcode, 12, 16)] =  sign_extend(cpu->memory->read_halfword(address), 16);
}
[/COMPONENT]

[COMPONENT LDM1_STM1]
- FORMAT:  ----100PU0WL--------------------
{
    uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)];

    @IF(U)  int mask = 1;
    @IF(!U) int mask = 0x8000; 

    @IF(U)  for (int i = 0;  i <  16; i++) {
    @IF(!U) for (int i = 15; i >= 0;  i--) {

        if (opcode & mask) {
            @IF( P  U) address += 4;
            @IF( P !U) address -= 4;

            @IF( L) cpu->regs[i] = cpu->memory->read_word(address);
            @IF(!L) cpu->memory->write_word(address, cpu->regs[i]);

            @IF(!P  U) address += 4;
            @IF(!P !U) address -= 4;
        }

        @IF(U)  mask <<= 1; 
        @IF(!U) mask >>= 1;
    }

    *cpu->pc &= 0xFFFFFFFE;
    
    @IF(W) cpu->regs[get_nth_bits(opcode, 16, 20)] = address;
}
[/COMPONENT]

[COMPONENT MUL_MLA]
- FORMAT:  ----000000AS------------1001----
{
    uint32_t* result = &cpu->regs[get_nth_bits(opcode, 16, 20)];
    *result = cpu->regs[get_nth_bits(opcode, 0, 4)] * cpu->regs[get_nth_bits(opcode, 8, 12)];
    @IF( A) *result += cpu->regs[get_nth_bits(opcode, 12, 16)];

    @IF( S) cpu->set_flag_Z(*result == 0);
    @IF( S) cpu->set_flag_N(*result >> 31);
}
[/COMPONENT]

[COMPONENT MOV_MVN]
- FORMAT:  ----00I11N1S--------------------
{
    @IF( N) uint32_t result = ~cpu->shifter_operand;
    @IF(!N) uint32_t result =  cpu->shifter_operand;

    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_N(result >> 31);
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S)     cpu->set_flag_C(cpu->shifter_carry_out);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT MRS]
- FORMAT:  ----00010R00------------0000----
{
    @IF(!R) cpu->regs[get_nth_bits(opcode, 12, 16)] = cpu->cpsr;
    @IF( R) cpu->regs[get_nth_bits(opcode, 12, 16)] = cpu->spsr;
}
[/COMPONENT]

[COMPONENT MSR]
- FORMAT:  ----00I10R10--------------------
{
    @IF( I) uint32_t  operand     = cpu->ROR(get_nth_bits(opcode, 0, 8), (get_nth_bits(opcode, 8, 12) * 2));
    @IF(!I) uint32_t  operand     = cpu->regs[get_nth_bits(opcode, 0, 4)];

    @IF( R) uint32_t* destination = &cpu->spsr;
    @IF(!R) uint32_t* destination = &cpu->cpsr;

    if (get_nth_bit(opcode, 16)) *destination = (*destination & 0xFFFFFF00) | (operand & 0x000000FF);
    if (get_nth_bit(opcode, 17)) *destination = (*destination & 0xFFFF00FF) | (operand & 0x0000FF00);
    if (get_nth_bit(opcode, 18)) *destination = (*destination & 0xFF00FFFF) | (operand & 0x00FF0000);
    if (get_nth_bit(opcode, 19)) *destination = (*destination & 0x00FFFFFF) | (operand & 0xFF000000);

    cpu->update_mode();
}
[/COMPONENT]

[COMPONENT ORR]
- FORMAT:  ----00I1100S--------------------
{
    uint32_t register_operand = cpu->regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4;
    uint32_t result = register_operand| cpu->shifter_operand;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_N(result >> 31);
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S)     cpu->set_flag_C(cpu->shifter_carry_out);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT RSB_RSC_SBC_SUB]
- FORMAT:  ----00I0C1RS--------------------
{
    uint32_t register_operand = cpu->regs[get_nth_bits(opcode, 16, 20)];
    if (get_nth_bits(opcode, 16, 20) == 15) register_operand += 4;
    @IF( R) uint32_t result   = cpu->shifter_operand - register_operand;
    @IF(!R) uint32_t result   = register_operand - cpu->shifter_operand;
    @IF( C)  result -= ((~cpu->get_flag_C()) & 1);

    cpu->regs[get_nth_bits(opcode, 12, 16)] = result;
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_N(result >> 31);
    @IF( S)     cpu->set_flag_Z(result == 0);

    @IF( S  R)  cpu->set_flag_C((cpu->shifter_operand >= register_operand));
    @IF( S  R)  cpu->set_flag_V(((register_operand >> 31) ^ (cpu->shifter_operand >> 31)) && ((register_operand >> 31) == (result >> 31)));
    @IF( S !R)  cpu->set_flag_C((cpu->shifter_operand <= register_operand));
    @IF( S !R)  cpu->set_flag_V(((cpu->shifter_operand >> 31) ^ (register_operand >> 31)) && ((cpu->shifter_operand >> 31) == (result >> 31)));
    
    @IF( S) }
}
[/COMPONENT]

[COMPONENT SMLAL]
- FORMAT:  ----0000111S------------1001----
{
    // unintuitive sign extension 
    // http://graphics.stanford.edu/~seander/bithacks.html#FixedSignExtend
    const uint64_t mask = 1U << (32 - 1);

    uint64_t result = ((((int64_t) cpu->regs[get_nth_bits(opcode, 0, 4)])  ^ mask) - mask) * 
                        ((((int64_t) cpu->regs[get_nth_bits(opcode, 8, 12)]) ^ mask) - mask);
    uint32_t* rd_lo = &cpu->regs[get_nth_bits(opcode, 12, 16)];
    uint32_t* rd_hi = &cpu->regs[get_nth_bits(opcode, 16, 20)];

    result += (((uint64_t) *rd_hi) << 32) | ((uint64_t) *rd_lo);
    *rd_lo = (uint32_t) (result & 0xFFFFFFFF);
    *rd_hi = (uint32_t) (result >> 32);
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S)     cpu->set_flag_N(result >> 63);
    @IF( S) }

    break;
}
[/COMPONENT]

[COMPONENT SMULL]
- FORMAT:  ----0000110S------------1001----
{
    // unintuitive sign extension 
    // http://graphics.stanford.edu/~seander/bithacks.html#FixedSignExtend
    const uint64_t mask = 1U << (32 - 1);

    uint64_t result = ((((int64_t) cpu->regs[get_nth_bits(opcode, 0, 4)])  ^ mask) - mask) * 
                      ((((int64_t) cpu->regs[get_nth_bits(opcode, 8, 12)]) ^ mask) - mask);

    cpu->regs[get_nth_bits(opcode, 12, 16)] = (uint32_t) (result & 0xFFFFFFFF);
    cpu->regs[get_nth_bits(opcode, 16, 20)] = (uint32_t) (result >> 32);

    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S)     cpu->set_flag_N(result >> 63);
    @IF( S) }
}
[/COMPONENT]

[COMPONENT STR]
- FORMAT:  ----01IPU0W0--------------------
{
    uint32_t result = cpu->regs[get_nth_bits(opcode, 12, 16)];
    if (get_nth_bits(opcode, 12, 16) == 15) result += 4;
    cpu->memory->write_word(address & 0xFFFFFFFC, result);
}
[/COMPONENT]

[COMPONENT STRB]
- FORMAT:  ----01IPU1W0--------------------
{
    cpu->memory->write_byte(address, cpu->regs[get_nth_bits(opcode, 12, 16)] & 0xFF);
}
[/COMPONENT]

[COMPONENT STRH]
- FORMAT:  ----000PUIW0------------1011----
{
    cpu->memory->write_halfword(address & ~1, cpu->regs[get_nth_bits(opcode, 12, 16)] & 0xFFFF);
}
[/COMPONENT]

[COMPONENT SWP]
- FORMAT: ----00010000------------1001----
{
    uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)];
    uint32_t value   = cpu->memory->read_word(address & 0xFFFFFFFC);
    if ((address & 0b11) == 0b01) value = ((value & 0xFF)     << 24) | (value >> 8);
    if ((address & 0b11) == 0b10) value = ((value & 0xFFFF)   << 16) | (value >> 16);
    if ((address & 0b11) == 0b11) value = ((value & 0xFFFFFF) << 8)  | (value >> 24);
    
    cpu->memory->write_word(address & 0xFFFFFFFC, cpu->regs[get_nth_bits(opcode, 0, 4)]);
    cpu->regs[get_nth_bits(opcode, 12, 16)] = value;
}
[/COMPONENT]

[COMPONENT SWPB]
- FORMAT: ----00010100------------1001----
{
    uint32_t temp = cpu->memory->read_byte(cpu->regs[get_nth_bits(opcode, 16, 20)]);
    cpu->memory->write_byte(cpu->regs[get_nth_bits(opcode, 16, 20)], cpu->regs[get_nth_bits(opcode, 0, 4)] & 0xFF);
    cpu->regs[get_nth_bits(opcode, 12, 16)] = temp;
}
[/COMPONENT]

[COMPONENT UMLAL]
- FORMAT:  ----0000101S------------1001----
{
    uint64_t result = ((uint64_t) cpu->regs[get_nth_bits(opcode, 0, 4)]) * 
                      ((uint64_t) cpu->regs[get_nth_bits(opcode, 8, 12)]);
    uint32_t* rd_lo = &cpu->regs[get_nth_bits(opcode, 12, 16)];
    uint32_t* rd_hi = &cpu->regs[get_nth_bits(opcode, 16, 20)];

    result += (((uint64_t) *rd_hi) << 32) | ((uint64_t) *rd_lo);
    *rd_lo = (uint32_t) (result & 0xFFFFFFFF);
    *rd_hi = (uint32_t) (result >> 32);
    
    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S)     cpu->set_flag_N(result >> 63);
    @IF( S) }

    break;
}
[/COMPONENT]

[COMPONENT UMULL]
- FORMAT:  ----0000100S------------1001----
{
    uint64_t result = ((uint64_t) cpu->regs[get_nth_bits(opcode, 0, 4)]) * 
                      ((uint64_t) cpu->regs[get_nth_bits(opcode, 8, 12)]);

    cpu->regs[get_nth_bits(opcode, 12, 16)] = (uint32_t) (result & 0xFFFFFFFF);
    cpu->regs[get_nth_bits(opcode, 16, 20)] = (uint32_t) (result >> 32);

    @IF( S) if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
    @IF( S)     cpu->cpsr = cpu->spsr;
    @IF( S) } else {
    @IF( S)     cpu->set_flag_Z(result == 0);
    @IF( S)     cpu->set_flag_N(result >> 63);
    @IF( S) }
}
[/COMPONENT]