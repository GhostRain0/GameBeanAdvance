[SETTINGS]
- NAMESPACE: arm
- OPCODE_FORMAT: IIIIIIIIIIII------------DDDD----
- INCLUDES: iostream ../util.h ../arm7tdmi.h
- ARGUMENTS: ARM7TDMI* cpu
[/SETTINGS]

[RULE B_BL]
- INCLUDE: ----101-------------------------
- COMPONENT: B_BL
[/RULE]

[RULE EOR]
- INCLUDE: ----00-0001---------------------
- COMPONENT: ADDRESSING_MODE_1
- COMPONENT: EOR
[/RULE]

[RULE LDR]
- INCLUDE: ----01---0-1--------------------
- COMPONENT: ADDRESSING_MODE_2
- COMPONENT: LDR
[/RULE]

[RULE LDRB]
- INCLUDE: ----01---1-1--------------------
- COMPONENT: ADDRESSING_MODE_2
- COMPONENT: LDRB
[/RULE]

[RULE LDRH]
- INCLUDE: ----000----1------------1011----
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: LDRH
[/RULE]

[RULE LDRSB]
- INCLUDE: ----000----1------------1101----
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: LDRSB
[/RULE]

[RULE LDRSH]
- INCLUDE: ----000----1------------1111----
- COMPONENT: ADDRESSING_MODE_3
- COMPONENT: LDRSH
[/RULE]

[COMPONENT ADDRESSING_MODE_1]
- FORMAT:  ----001-------------------------
{
    cpu->shifter_operand   = cpu->ROR(get_nth_bits(opcode, 0, 8), ((get_nth_bits(opcode, 8, 12)) * 2));
    cpu->shifter_carry_out = get_nth_bits(opcode, 8, 12) == 0 ? cpu->get_flag_C() : get_nth_bit(cpu->shifter_operand, 31);
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_1]
- FORMAT:  ----000------------------SH0----
{
    uint32_t shift_immediate = get_nth_bits(opcode, 7, 12);
    uint32_t rm              = cpu->regs[get_nth_bits(opcode, 0, 4)];

    if (get_nth_bits(opcode, 0, 4) == 15) // are we PC?
        rm += 4;
    
    // S being false and H being false indicates a left shift... sort of. there's a special case when
    // shift_immediate == 0
    @IF(!S !H) if (shift_immediate == 0) {
    @IF(!S !H)     cpu->shifter_operand   = rm;
    @IF(!S !H)     cpu->shifter_carry_out = cpu->get_flag_C();
    @IF(!S !H) } else { // shift_immediate > 0
    @IF(!S !H)     cpu->shifter_operand   = cpu->LSL(rm, shift_immediate);
    @IF(!S !H)     cpu->shifter_carry_out = get_nth_bit(rm, 32 - shift_immediate);
    @IF(!S !H) }

    // S being false and H being true indicates a right shift... also sort of. there's a special case when
    // shift_immediate == 0
    @IF(!S  H) if (shift_immediate == 0) {
    @IF(!S  H)     cpu->shifter_operand   = 0;
    @IF(!S  H)     cpu->shifter_carry_out = get_nth_bit(rm, 31);
    @IF(!S  H) } else { // shift_immediate > 0
    @IF(!S  H)     cpu->shifter_operand   = cpu->LSR(rm, shift_immediate);
    @IF(!S  H)     cpu->shifter_carry_out = get_nth_bit(rm, shift_immediate - 1);
    @IF(!S  H) }

    // S being true and H being false indicates an arithmetic shift.
    @IF( S !H) if (shift_immediate == 0) {
    @IF( S !H)     cpu->shifter_operand   = get_nth_bit(rm, 31) ? 0xFFFFFFFF : 0x00000000;
    @IF( S !H)     cpu->shifter_carry_out = get_nth_bit(rm, 31);
    @IF( S !H) } else { // shift_immediate > 0
    @IF( S !H)     cpu->shifter_operand   = cpu->ASR(rm, shift_immediate);
    @IF( S !H)     cpu->shifter_carry_out = get_nth_bit(rm, shift_immediate - 1);
    @IF( S !H) }
        
    // S being true and H being true indicates either RO or RRX, depending on if 
    // shift_immediate is 0
    @IF( S  H) if (shift_immediate == 0) { // RRX
    @IF( S  H)     cpu->shifter_operand   = cpu->get_flag_C() << 31 | cpu->LSR(rm, 1);
    @IF( S  H)     cpu->shifter_carry_out = get_nth_bit(rm, 0); 
    @IF( S  H) } else { // shift_immediate > 0, ROR
    @IF( S  H)     cpu->shifter_operand   = cpu->ROR(rm, shift_immediate);
    @IF( S  H)     cpu->shifter_carry_out = get_nth_bit(rm, shift_immediate - 1);
    @IF( S  H) }
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_1]
- FORMAT:  ----000------------------SH1----
{
    uint32_t rm = cpu->regs[get_nth_bits(opcode, 0, 4)];
    uint32_t rs = get_nth_bits(cpu->regs[get_nth_bits(opcode, 8, 12)], 0, 8);
    
    if (get_nth_bits(opcode, 4, 12) == 0) { 
        if (get_nth_bits(opcode, 0, 4) == 15) // are we PC?
            rm += 4;

        cpu->shifter_operand   = rm;
        cpu->shifter_carry_out = cpu->get_flag_C();
    }

    // There's a lot of exceptions to the rules here, because rs can be
    // 32 bits long, and that causes some problems. immediate shift had
    // a limit of 5 bits.

    // S being false and H being false indicates a left shift
    @IF(!S !H) if        (rs == 0) {
    @IF(!S !H)     cpu->shifter_operand   = rm;
    @IF(!S !H)     cpu->shifter_carry_out = cpu->get_flag_C();
    @IF(!S !H) } else if (rs < 32) {
    @IF(!S !H)     cpu->shifter_operand   = cpu->LSL(rm, rs);
    @IF(!S !H)     cpu->shifter_carry_out = get_nth_bit(rm, 32 - rs);
    @IF(!S !H) } else if (rs == 32) {
    @IF(!S !H)     cpu->shifter_operand   = 0;
    @IF(!S !H)     cpu->shifter_carry_out = get_nth_bit(rm, 0);
    @IF(!S !H) } else if (rs > 32) {
    @IF(!S !H)     cpu->shifter_operand   = 0;
    @IF(!S !H)     cpu->shifter_carry_out = 0;
    @IF(!S !H) }

    // S being false and H being true indicates a right shift
    @IF(!S  H) if        (rs == 0) {
    @IF(!S  H)     cpu->shifter_operand   = rm;
    @IF(!S  H)     cpu->shifter_carry_out = cpu->get_flag_C();
    @IF(!S  H) } else if (rs < 32) {
    @IF(!S  H)     cpu->shifter_operand   = cpu->LSR(rm, rs);
    @IF(!S  H)     cpu->shifter_carry_out = get_nth_bit(rm, rs - 1);
    @IF(!S  H) } else if (rs == 32) {
    @IF(!S  H)     cpu->shifter_operand   = 0;
    @IF(!S  H)     cpu->shifter_carry_out = get_nth_bit(rm, 31);
    @IF(!S  H) } else if (rs > 32) {
    @IF(!S  H)     cpu->shifter_operand   = 0;
    @IF(!S  H)     cpu->shifter_carry_out = 0;
    @IF(!S  H) }
        
    // S being true and H being false indicates ASR
    @IF( S !H) if        (rs == 0) {
    @IF( S !H)     cpu->shifter_operand   = rm;
    @IF( S !H)     cpu->shifter_carry_out = cpu->get_flag_C();
    @IF( S !H) } else if (rs < 32) {
    @IF( S !H)     cpu->shifter_operand   = cpu->ASR(rm, rs);
    @IF( S !H)     cpu->shifter_carry_out = get_nth_bit(rm, rs - 1);
    @IF( S !H) } else { // rs >= 32
    @IF( S !H)     cpu->shifter_operand   = get_nth_bit(rm, 31) ? 0xFFFFFFFF : 0x00000000;
    @IF( S !H)     cpu->shifter_carry_out = get_nth_bit(rm, 0);
    @IF( S !H) }

    // S and H being true indicates ROR
    @IF( S  H) if        (rs == 0) {
    @IF( S  H)     cpu->shifter_operand   = rm;
    @IF( S  H)     cpu->shifter_carry_out = cpu->get_flag_C();
    @IF( S  H) } else if ((rs & 0xF) == 0) {
    @IF( S  H)     cpu->shifter_operand   = rm;
    @IF( S  H)     cpu->shifter_carry_out = get_nth_bit(rm, 31);
    @IF( S  H) } else { // rs & 0xF > 0
    @IF( S  H)     cpu->shifter_operand   = cpu->ROR(rm, rs & 0xF);
    @IF( S  H)     cpu->shifter_carry_out = get_nth_bit(rs, rm & 0xF - 1);
    @IF( S  H) }
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_2]
- FORMAT:  ----010PUBWL--------------------
{
    // NOTE: this is the IMMEDIATE OFFSET part of ADDRESSING_MODE_2
    // also yes it does look very similar to ADDRESSING_MODE_3 but what can I realistically do,
    // this was the way the cpu was designed.
    // actually, this can be made cleaner if i allow components to contain components.... maybe
    // a task for another day.
    
    // pc is required to know if we should add an extra offset of 4 to account for the pipeline
    bool is_pc = get_nth_bits(opcode, 16, 20) == 15;

    // this is immediate addressing - so we just get the offset straight from the opcode
    uint32_t offset = get_nth_bits(opcode, 0, 12);

    // U determines if we add or subtract
    // O determines if we're doing post-indexed addressing or not
    @IF( P  U) uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)] + offset + (is_pc ? 4 : 0);
    @IF( P !U) uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)] - offset + (is_pc ? 4 : 0);

    @IF(!P)    uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)];
    @IF(!P  U) cpu->regs[get_nth_bits(opcode, 16, 20)] += offset + (is_pc ? 4 : 0);
    @IF(!P !U) cpu->regs[get_nth_bits(opcode, 16, 20)] -= offset + (is_pc ? 4 : 0);

    // if the writeback bit is specified, then do a writeback.
    @IF( W) cpu->regs[get_nth_bits(opcode, 16, 20)] = address;
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_2]
- FORMAT:  ----011PUBWL-------------SH-----
{
    uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)];
    uint32_t operand = cpu->regs[get_nth_bits(opcode, 0,  4)];
    uint32_t shift_immediate = get_nth_bits(opcode, 7, 12);

    uint32_t index = 0;

    // S being false indicates a shift of some type
    @IF(!S !H) index = operand << shift_immediate;
    @IF(!S  H) index = operand >> shift_immediate;

    // S being true but H being false indicates an arithmetic shift
    @IF( S !H) if (shift_immediate != 0) {
    @IF( S !H)     if ((operand >> 31) == 1) {
    @IF( S !H)         index = (((1 << shift_immediate) - 1) << (32 - shift_immediate)) | (operand >> shift_immediate);
    @IF( S !H)     } else {
    @IF( S !H)         index = operand >> shift_immediate;
    @IF( S !H)     }
    @IF( S !H) }
    @IF( S !H) else index = (get_nth_bit(shift_immediate, 31) == 1 ? 0xFFFFFFFF : 0x00000000);

    // S being true and H being true indicates a rotate right or a rotate right with extend.
    @IF( S  H) if (shift_immediate != 0) {
    @IF( S  H)     uint32_t rotated_off = get_nth_bits(operand, 0, shift_immediate);  // the value that is rotated off
    @IF( S  H)     uint32_t rotated_in  = get_nth_bits(operand, shift_immediate, 32); // the value that stays after the rotation
    @IF( S  H)     index = rotated_in | (rotated_off << (32 - shift_immediate));
    @IF( S  H) }
    @IF( S  H) else {
    @IF( S  H)     uint32_t rotated_off = get_nth_bit(operand, 0);      // the value that is rotated off
    @IF( S  H)     uint32_t rotated_in  = get_nth_bits(operand, 1, 32); // the value that stays after the rotation

    @IF( S  H)     index = rotated_in | (rotated_off << 31);
    @IF( S  H)     cpu->set_flag_C(get_nth_bit(operand, shift_immediate));
    @IF( S  H) }

     // P bit being set indicates offset addressing or pre-indexed addressing
    @IF( P  U) address += index;
    @IF( P !U) address -= index;

    @IF( P  W) cpu->regs[get_nth_bits(opcode, 16, 20)] = address;
    
    // P bit being clear indicates post-indexed addressing
    @IF(!P  U) cpu->regs[get_nth_bits(opcode, 16, 20)] += index;
    @IF(!P !U) cpu->regs[get_nth_bits(opcode, 16, 20)] -= index;
    
    if (get_nth_bits(opcode, 16, 20) == 15) { // are we register PC?
        address += 4;
    }
}
[/COMPONENT]

[COMPONENT ADDRESSING_MODE_3]
- FORMAT:  ----00OPUIWL--------------------
{
    // pc is required to know if we should add an extra offset of 4 to account for the pipeline
    bool is_pc = get_nth_bits(opcode, 16, 20) == 15;

    // we either get the offset straight from the opcode or from the registers depending on the I bit
    @IF( I) uint8_t  offset = get_nth_bits(opcode, 0, 4) | (get_nth_bits(opcode, 8, 12) << 4);
    @IF(!I) uint32_t offset = cpu->regs[get_nth_bits(opcode, 0, 4)];

    // U determines if we add or subtract
    // P determines if we're doing post-indexed addressing or not
    @IF( P  U) uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)] + offset + (is_pc ? 4 : 0);
    @IF( P !U) uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)] - offset + (is_pc ? 4 : 0);

    @IF(!P)    uint32_t address = cpu->regs[get_nth_bits(opcode, 16, 20)];
    @IF(!P  U) cpu->regs[get_nth_bits(opcode, 16, 20)] += offset + (is_pc ? 4 : 0);
    @IF(!P !U) cpu->regs[get_nth_bits(opcode, 16, 20)] -= offset + (is_pc ? 4 : 0);

    // if the writeback bit is specified, then do a writeback.
    @IF( W) cpu->regs[get_nth_bits(opcode, 16, 20)] = address;
}
[/COMPONENT]

[COMPONENT B_BL]
- FORMAT:  ----101L------------------------
{
    @IF(L) *cpu->lr = *cpu->pc;
    // unintuitive sign extension: http://graphics.stanford.edu/~seander/bithacks.html#FixedSignExtend
    *cpu->pc += ((((1U << 23) ^ get_nth_bits(opcode, 0, 24)) - (1U << 23)) << 2) + 4;
}
[/COMPONENT]

[COMPONENT EOR]
- FORMAT:  ----00I0001S--------------------
{
    uint32_t* rd = &cpu->regs[get_nth_bits(opcode, 12, 16)];
    *rd = cpu->regs[get_nth_bits(opcode, 16, 20)] ^ cpu->shifter_operand;

    if (get_nth_bit(opcode, 20)) {
        if (get_nth_bits(opcode, 12, 16) == 15) { // are we register PC?
            cpu->cpsr = cpu->spsr;
        } else {
            cpu->set_flag_N(*rd >> 31);
            cpu->set_flag_Z(*rd == 0);
            cpu->set_flag_C(cpu->shifter_carry_out);
        }
    }
}
[/COMPONENT]

[COMPONENT LDR]
- FORMAT:  ----01---0-1--------------------
{
    uint32_t value = cpu->memory->read_word(address & 0xFFFFFFFC);
    if ((address & 0b11) == 0b01) value = ((value & 0xFF)     << 24) | (value >> 8);
    if ((address & 0b11) == 0b10) value = ((value & 0xFFFF)   << 16) | (value >> 16);
    if ((address & 0b11) == 0b11) value = ((value & 0xFFFFFF) << 8)  | (value >> 24);

    uint8_t rd = get_nth_bits(opcode, 12, 16);
    if (rd == 15) {
        *cpu->pc = value & 0xFFFFFFFC;
    } else {
        cpu->regs[rd] = value;
    }
}
[/COMPONENT]

[COMPONENT LDRB]
- FORMAT:  ----01---1-1--------------------
{
    cpu->regs[get_nth_bits(opcode, 12, 16)] = cpu->memory->read_byte(address);
}
[/COMPONENT]

[COMPONENT LDRH]
- FORMAT:  ----000----1--------------------
{
    cpu->regs[get_nth_bits(opcode, 12, 16)] = cpu->memory->read_halfword(address);
}
[/COMPONENT]

[COMPONENT LDRSB]
- FORMAT:  ----000----1------------1101----
{
    cpu->regs[get_nth_bits(opcode, 12, 16)] = sign_extend(cpu->memory->read_byte(address), 8);
}
[/COMPONENT]

[COMPONENT LDRSH]
- FORMAT:  ----000----1------------1111----
{
    cpu->regs[get_nth_bits(opcode, 12, 16)] =  sign_extend(cpu->memory->read_halfword(address), 16);
}
[/COMPONENT]